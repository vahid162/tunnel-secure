#!/usr/bin/env bash
set -euo pipefail

BACKUP_DIR="/root/tunnel-secure-backups"
SSH_DROPIN_DIR="/etc/ssh/sshd_config.d"
SSH_DROPIN="$SSH_DROPIN_DIR/00-tunnel-secure.conf"

red() { printf '\033[31m%s\033[0m\n' "$*"; }
green() { printf '\033[32m%s\033[0m\n' "$*"; }
yellow() { printf '\033[33m%s\033[0m\n' "$*"; }
blue() { printf '\033[34m%s\033[0m\n' "$*"; }

need_root() {
  if [[ $EUID -ne 0 ]]; then
    red "This script must be run as root."
    exit 1
  fi
}

validate_port() {
  local port="$1"
  [[ "$port" =~ ^[0-9]+$ ]] || return 1
  (( port >= 1 && port <= 65535 ))
}

usage() {
  cat <<USAGE
Usage:
  sudo bash scripts/tunnel-security-emergency-ssh-recover.sh [--port 22]

What it does:
  1) Backs up current SSH/UFW config to $BACKUP_DIR
  2) Temporarily disables other sshd drop-ins and writes a minimal safe SSH drop-in
  3) Validates sshd config and restarts ssh service
  4) Opens SSH port in UFW + iptables to restore access quickly
  5) Prints post-check diagnostics (sshd status, listening port, firewall)

Use this ONLY from emergency console (VNC/KVM/provider console).
USAGE
}

backup_file() {
  local src="$1"
  mkdir -p "$BACKUP_DIR"
  if [[ -f "$src" ]]; then
    cp -a "$src" "$BACKUP_DIR/$(basename "$src").$(date +%F-%H%M%S).bak"
  fi
}

disable_other_dropins() {
  local stash_dir
  local found_any="no"

  stash_dir="$BACKUP_DIR/sshd-dropins-disabled-$(date +%F-%H%M%S)"
  mkdir -p "$stash_dir"

  shopt -s nullglob
  for f in "$SSH_DROPIN_DIR"/*.conf; do
    if [[ "$f" == "$SSH_DROPIN" ]]; then
      continue
    fi
    cp -a "$f" "$stash_dir/"
    rm -f "$f"
    found_any="yes"
  done
  shopt -u nullglob

  if [[ "$found_any" == "yes" ]]; then
    yellow "Other sshd drop-ins were temporarily disabled and backed up to: $stash_dir"
  fi
}

ensure_iptables_allow() {
  local ssh_port="$1"

  if command -v iptables >/dev/null 2>&1; then
    iptables -C INPUT -p tcp --dport "$ssh_port" -j ACCEPT >/dev/null 2>&1 || \
      iptables -I INPUT 1 -p tcp --dport "$ssh_port" -j ACCEPT || true
  fi

  if command -v ip6tables >/dev/null 2>&1; then
    ip6tables -C INPUT -p tcp --dport "$ssh_port" -j ACCEPT >/dev/null 2>&1 || \
      ip6tables -I INPUT 1 -p tcp --dport "$ssh_port" -j ACCEPT || true
  fi
}

print_post_checks() {
  local ssh_port="$1"

  blue "[Post-check] ssh service"
  systemctl --no-pager --full status ssh 2>/dev/null || systemctl --no-pager --full status sshd 2>/dev/null || true

  blue "[Post-check] listening sockets for SSH port ${ssh_port}"
  ss -lntp 2>/dev/null | awk -v p=":${ssh_port}" 'NR==1 || $4 ~ p' || true

  blue "[Post-check] UFW"
  ufw status verbose 2>/dev/null || true

  blue "[Post-check] route and main IP"
  ip -4 route get 1.1.1.1 2>/dev/null || true

  yellow "If SSH is still unreachable from outside but service is listening,"
  yellow "the remaining blocker is usually provider/cloud firewall or upstream ACL."
}

main() {
  need_root

  local ssh_port="22"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port)
        ssh_port="${2:-}"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        red "Unknown argument: $1"
        usage
        exit 1
        ;;
    esac
  done

  if ! validate_port "$ssh_port"; then
    red "Invalid port: $ssh_port"
    exit 1
  fi

  blue "[1/5] Backup current config"
  backup_file "$SSH_DROPIN"
  backup_file /etc/default/ufw
  if [[ -d /etc/ufw ]]; then
    tar -czf "$BACKUP_DIR/ufw.emergency.$(date +%F-%H%M%S).tar.gz" /etc/ufw >/dev/null 2>&1 || true
  fi

  blue "[2/5] Write emergency SSH drop-in"
  mkdir -p "$SSH_DROPIN_DIR"
  disable_other_dropins
  cat > "$SSH_DROPIN" <<EOC
# Generated by tunnel-security emergency recovery
Port ${ssh_port}
ListenAddress 0.0.0.0
PermitRootLogin yes
PasswordAuthentication yes
KbdInteractiveAuthentication yes
ChallengeResponseAuthentication yes
UsePAM yes
PubkeyAuthentication yes
EOC

  blue "[3/5] Validate and restart SSH"
  if ! sshd -t; then
    red "sshd config validation failed."
    exit 1
  fi
  systemctl restart ssh || systemctl restart sshd

  blue "[4/5] Open SSH in firewall"
  if command -v ufw >/dev/null 2>&1; then
    ufw --force disable || true
    ufw --force reset || true
    ufw default deny incoming || true
    ufw default allow outgoing || true
    ufw allow "$ssh_port"/tcp comment 'emergency ssh recover' || true
    ufw --force enable || true
  else
    yellow "ufw not installed; skipped UFW step."
  fi
  ensure_iptables_allow "$ssh_port"

  blue "[5/5] Disable fail2ban temporarily"
  if command -v fail2ban-client >/dev/null 2>&1; then
    fail2ban-client unban --all >/dev/null 2>&1 || true
  fi
  systemctl stop fail2ban >/dev/null 2>&1 || true
  systemctl disable fail2ban >/dev/null 2>&1 || true

  print_post_checks "$ssh_port"

  green "Emergency SSH recovery completed."
  yellow "Now test SSH login from a NEW terminal before closing console access."
  yellow "After login, re-run tunnel-security-wizard to re-apply secure settings."
}

main "$@"
